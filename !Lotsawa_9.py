import yaml
import re

#strn=input("insert tib str: ")

#with open('Tib_Txt.txt', 'r', encoding='utf-8') as f:
#    strn = f.read()

#---------------------------------------------------------------------------
# 0. Подготовка (форматирование) строки/текста
#1. отлепляем ->འི от слога
#strn=input()
strn = '''༄༅། །སྐྱེས་བུ་ཆེན་པོའི་ལམ་གྱི་རིམ་པ་ལས། ཐེག་ཆེན་གྱི་འཇུག་སྒོ་སེམས་བསྐྱེད་བཞུགས་སོ༔ སྨོན་སེམས་སྦྱང་བ་དང་རྒྱལ་སྲས་ཀྱི་སྤྱོད་པ་སྤྱི་ལ་བསླབ་པའི་ཚུལ། །ཐེག་ཆེན་གྱི་འཇུག་སྒོ་སེམས་བསྐྱེད་ཁོ་ནར་བསྟན་པ། །བྱང་ཆུབ་སེམས་སྦྱང་བ་རིམ་པ་ལ་ཇོ་བོ་ནས་བརྒྱུད་པ་རྒྱུ་འབྲས་མན་ངག་བདུན། །ཞི་བ་ལྷའི་གཞུང་ལ་བརྟེན་ནས་སྦྱུང་བ་ནི། །སེམས་བསྐྱེད་ནས་སྤྱོད་པ་ལ་སློབ་ཚུལ། །ཞར་ལ་གོ་རིམ་ངེས་པ། ༈ རྗེ་བཙུན་དམ་པ་ཐུགས་རྗེ་ཆེན་པོ་དང་ལྡན་པ་རྣམས་ཀྱི་ཞབས་ལ་གུས་པས་ཕྱག་འཚལ་ལོ། །དེ་ལྟར་འཁོར་བའི་ཉེས་དམིགས་སྒོ་སྣ་ཚོགས་ནས་རྒྱུན་རིང་དུ་བསྒོམས་པ་ལས་སྲིད་པ་ཐམས་ཅད་མེ་འབར་བའི་རླུབས་ལྟར་མཐོང་སྟེ། ཉོན་མོངས་པ་དང་སྡུག་བསྔལ་ཉེ་བར་ཞི་བའི་ཐར་པ་ལ་ཐོབ་འདོད་ཀྱིས་ཡིད་ཀུན་ཏུ་གདུངས་པ་དེས། ལམ་བསླབ་པ་རིན་པོ་ཆེ་གསུམ་ལ་བསླབས་ན་འཁོར་བ་ལས་གྲོལ་བའི་ཐར་པ་འཐོབ་ཅིང༌། དེ་ཡང་མཐོ་རིས་ཀྱི་དཔལ་ལྟར་སླར་ལྡོག་པ་ཡང་མ་ཡིན་མོད། འོན་ཀྱང་སྐྱོན་ཟད་པ་དང་ཡོན་ཏན་ཐོབ་པ་ཕྱོགས་རེ་བ་ཡིན་པས་རང་གི་དོན་མ་རྫོགས་ལ་དེ་ཉིད་ཀྱིས་ན་གཞན་གྱི་དོན་ཡང་ཉི་ཚེ་བར་ཟད་ཅིང༌། མཐར་སངས་རྒྱས་ཀྱིས་བསྐུལ་ནས་ཐེག་ཆེན་དུ་འཇུག་དགོས་པས་ན། བློ་དང་ལྡན་པ་རྣམས་ཀྱིས་ནི་ཐོག་མ་ནས་ཐེག་པ་ཆེན་པོར་འཇུག་པར་རིགས་ཏེ། །ཕར་ཕྱིན་བསྡུས་པ་ལས། །འཇིག་རྟེན་དོན་སྒྲུབ་ཚུལ་ལ་མཐུ་མེད་པའི། །ཐེག་པ་གཉིས་པོ་གཏན་དུ་སྤང་བྱས་ཤིང༌། །ཐུབ་རྒྱལ་ཐེག་པ་སྙིང་རྗེས་བསྟན་པ་ལ། །གཞན་ཕན་རོ་གཅིག་རང་བཞིན་དེ་དག་འཇུག །ཅེས་དང༌། །བདེ་དང་མི་བདེ་རྨི་ལམ་འདྲར་བགྲངས་ཤིང༌། །གཏི་མུག་སྐྱོན་གྱིས་དམའ་བའི་འགྲོ་མཐོང་ན། །ལས་ཀྱི་དམ་པ་གཞན་དོན་དགའ་བོར་ཞིང༌། །རང་གི་དོན་ལ་དེ་ཀོ་ཅི་སྟེ་བརྩོན། །ཞེས་གསུངས་པ་ལྟར་རོ།  །དེ་ལྟར་རང་ཉིད་སྲིད་པའི་མཚོར་ལྷུང་བ་དང་འདྲ་བར་འགྲོ་བ་རྣམས་ཀྱང་བླང་དོར་འབྱེད་པའི་ཤེས་རབ་ཀྱི་མིག་ཟུམ་པས་ཉམ་ང་བ་དང་བྲལ་བའི་ཕྱོགས་སུ་བགྲོད་མི་ནུས་པར་གོམ་འགྲོས་འཁྱོར་བ་མཐོང་ན། རྒྱལ་བའི་རིགས་དང་ལྡན་པ་རྣམས་གཞན་ལ་བརྩེ་བ་མེད་པ་དང་དེ་དག་གི་དོན་དུ་མི་བརྩོན་པ་ནི་མི་རིགས་ཏེ། །དེ་ཉིད་ལས། །ཤེས་རབ་མིག་ཟུམ་འགྲོས་འཁྱོར་གྱུར་པ་ལ། །འཇིག་རྟེན་དོན་སྒྲུབ་རྒྱལ་བའི་རྒྱལ་རིགས་ན། །སྙིང་རྗེ་མི་བསྐྱེད་སྐྱེས་བུ་གང་ཞིག་ཡོད། །དེ་དག་རྨོངས་བསལ་བརྩོན་འགྲུས་སུ་མི་རྩོམ། །ཞེས་སོ།  །འདི་ན་སྐྱེས་བུ་རྣམས་ཀྱི་བདེ་བ་དང་བརྗིད་བག་དང་སྐྱེས་བུའི་རྩལ་ནི་གཞན་གྱི་དོན་ཁུར་དུ་འཁྱེར་བ་ལ་བྱ་བར་རིགས་ཏེ། རང་གི་དོན་ཙམ་ལ་དམིགས་པ་ནི་དུད་འགྲོ་རྣམས་དང་ཡང་ཐུན་མོང་བ་ཡིན་པའི་ཕྱིར་རོ། །དེའི་ཕྱིར་ཆེན་པོ་རྣམས་ཀྱི་ངང་ཚུལ་ནི་གཞན་གྱི་ཕན་བདེ་ལ་མཐའ་གཅིག་ཏུ་གཞོལ་བ་ཡིན་ཏེ། །སློབ་མ་ལ་སྤྲིངས་པ་ལས། །ཤིན་ཏུ་རྙེད་སླའི་རྩྭ་ཁམ་འགའ་ལྟ་ཕྱུགས་ཀྱང་རང་ཉིད་ཟ། །ཤིན་ཏུ་སྐོམ་པས་གདུངས་པའང་ཆུ་ཞིག་རྙེད་ན་དགའ་མགུར་འཐུང༌། །འདི་ན་སྐྱེས་བུ་གཞན་དོན་བྱེད་པར་བརྩོན་པ་གང་ཡིན་པ། །དེ་འདིའི་བརྗིད་བག་ཡིན་ཏེ་དེ་བདེ་སྐྱེས་བུའི་རྩལ་དེ་འཕགས། །ཉི་མ་རླབས་ཆེན་རྟ་ཞོན་རྒྱུ་བ་སྣང་བྱེད་གང་ཡིན་དང༌། །ཁུར་ལ་མི་རྩེག་ས་ཡིས་འཇིག་རྟེན་འདེགས་པ་གང་ཡིན་དེ། །རང་དོན་འགའ་མེད་ཆེན་པོ་རྣམས་ཀྱི་རང་བཞིན་དེ་འདྲ་སྟེ། །དེ་དག་འཇིག་རྟེན་ཕན་དང་བདེ་བའི་རོ་ལ་གཅིག་ཏུ་གཞོལ། །ཞེས་སོ།  །དེ་ལྟར་འགྲོ་བ་སྡུག་བསྔལ་གྱིས་ཀུན་ཏུ་གདུངས་པར་མཐོང་ནས་དེ་དག་གི་དོན་དུ་བྲེལ་བ་ལ་སྐྱེས་བུ་ཞེས་བྱ་ལ་མཁས་པ་ཞེས་ཀྱང་དེ་ལ་བྱ་སྟེ'''

strn+=' '

strn=re.sub(f'༌', '་', strn,0) 

#0.Предложение ч1
strn=re.sub(f'([༄༅\s\n\t༈།]*)(\S*[༔།/s]*)', '\\1@\\2&', strn,0) 
strn=re.sub(f'@&', '', strn,0) 

# 0.1. Название
strn=re.sub(r'([༄༅།\s@]+\S+?ལས[།༔]&)\s+(\S+?་བཞུགས\S*[།༔]*&)', '<h1 class="Toc">\\1 \\2</h1> <br>\\n',strn, 0)

# 0.2. Тема - подзаголовок
strn=re.sub(r'(\S+?ནི[།༔]&)', '\\n<br><h4 class="Topic">\\1</h4> <br>\\n',strn, 0)   

# 0.3. Новая глава
strn=re.sub(r'(༈)', '\\n\\n<br><br>\\1',strn)

# 0.4. Цитата до первого окончания
strn=re.sub(r'([།])@(\S+?ལས[༔།]+)&\s+(.+?[༔།་]*)\s([།]([@]ཞེས|ཅེས).+?[༔།&]+)', '\\n<br><snt class=\"cite_src\">\\1\\2</snt> <div class=\"cite\">\\3</div> <br>\\n\\4<br>\\n',strn, 0)

# 0.4. Цитата продолжение
strn=re.sub(r'([།]@(ཞེས|ཅེས).+?དང[༔།་]*&)(<br>\n)*\s*(.+?[༔།་&]*)\s([།]@(ཞེས|ཅེས).+?[༔།&]+)', '</div>\\1 <div class="cite">\\4</div> <br>\\n\\5<br>\\n',strn, 0)  

#0.5 Конец абзаца (заключающий помощник གོ ངོ དོ ནོ བོ མོ རོ ལོ སོ ཏོ после второго суффикса ད་; འོ་ - после слога без суффикса)
strn=re.sub(f'((ག་གོ|ང་ངོ[་]*|ད་དོ|ན་ནོ|བ་བོ|མ་མོ|ར་རོ|ལ་ལོ|ས་སོ|ད་ཏོ|འོ)([༔།{1,2}&\s\t])+)[།\s]', '\\1<br><br>\\n\\n ',strn)    
strn=re.sub(f'(ག་གོ|ང་ངོ[་]*|ད་དོ|ན་ནོ|བ་བོ|མ་མོ|ར་རོ|ལ་ལོ|ས་སོ|ད་ཏོ|འོ)([༔།&\s\t])', '\\1#\\2',strn)  

#0.6 Разделительные частицы - не выполняем
#strn=re.sub(f'(་)(གི|ཀྱི|གྱི|ཡི|གིས|ཀྱིས|གྱིས|ཡིས|སུ|རུ|ཏུ|ན|ལ|དུ|ཏེ|དེ|སྟེ|དང|ཞིང|ཅིང|ཤིང|ཀྱང|ཡང)([་།༔&])', '\\1<a class="cc">\\2</a>\\3',strn)    
#strn=re.sub(f'(འི|འིས|འང|འམ)|འང([་།༔&])', '<a class="cc">\\1\\2</a>',strn)    

#0.7 Предложение ч2
lst=strn.split('@')

strng=''
strng=lst[0]
i=1
while i in range(len(lst)):  
    strng+=f'<snt class="sent" id="s{i}">{lst[i]}'          
    i+=1

strn=strng.replace('&','</snt>')
strn=re.sub(r'@(.+?)&', f'<snt class="sent" id="{i}">\\1</snt>',strn,0)  
  
#print(strn)
#---------------------------------------------------------------------------
#1. отлепляем ->འི от слога
for syl in ['འིས', 'འང', 'འམ', 'འི', 'འུ']:  # исключил доп.строк - 'འུ'
    strn = re.sub(f'([་\S])({syl})([་།༔])', r"\1་\2\3", strn)
strn = re.sub(f'([་\S])(པ|པོ|བོ|དེ|འདི)(ར)', r"\1\2་\3", strn)
strn = re.sub(f'(་)(པ|པོ|བ|བོ|དེ|འདི)(ས་)', r"\1\2་\3", strn)

#print(strn)

#2. Парсим Строку для перевода -> list список слов из строки
strn_lst = re.findall(
    r'[༄༅།༼༽ ༿༧་༈|\"\'=<\a-z>]*(\S+?)[་༔༈།༾ཿ\s<\a-z>\"\'=/|]+', strn)

#3. присоединяем персонификаторы к пред слогу в -> strn_lst
for ind, syl in enumerate(strn_lst):
    if syl in ['པོ', 'བོ', 'མོ', 'ཀོ', 'ཅན', 'ལྡན', 'མཁན']:  # исключил - མ, ཀ, ཁ, ག, པ, བ,
        strn_lst[ind-1] = strn_lst[ind-1]+'་'+strn_lst.pop(ind)

# TODO Усложняем логику парсинга
#print(res_strn)
strn_lst = list(set(strn_lst))
strn_lst.sort(key=len, reverse=True)  # сортируем - max_len в начало
print(strn_lst)

#---------------------------------------------------------------------------
# А.Парсим D7000_3.yaml -> dict
with open('D7000_3.yaml', 'r', encoding='utf-8')as f:
    dct_ptcl = yaml.full_load(f)
# --------------------------------------------------------
#2.б)Ищем частицы всоставе словосочетаний пословарю;
# в)Ищем словосочетания по строке
# strn              исходная строка для перевода
# strn_lst          список слов из строки для перевода
# dct_ptcl          словарь частиц из D7000_3.yaml

# sent_lst          список сочетаний со словом из strn_lst
res_strn = strn     # копия исходной строка для перевода
res_dct = {}        # словарь найденных вхождений sent в исход строку

for ind, syl in enumerate(strn_lst):  # по кажд уник слогу в strn_lst
    pattern = f'\'(\S*{syl}\S*?)[་།༔༈]*\':'
    #print('syl-',syl)

    # Б.Поиск по Dict.dict всех вариантов куда входит слог из strn_lst -> sent_lst[список_словосочетаний]
    sent_lst = list(set(re.findall(pattern, str(dct_ptcl))))
    sent_lst.sort(key=len, reverse=True)  # сортируем - max_len в начало
    #print("сент_лст--", sent_lst)

    #В.Поиск по strn каждого уник из sent_lst в строке
    for sent in sent_lst:
        #print("сет-", sent)
        #ind=res_strn.find(sent)
        if sent in strn and sent not in res_dct:  # если sent в исход строке И sent не находили ранее
            # из исход строки убираем найденное sent
            strn = re.sub(
                f'([་།༽༼ ༿\s>]+)({str(sent)})([་༽༈།༔༾\s<]+)', r'\1|\3', strn)
            # в дубль_строке заменяем sent
            res_strn = re.sub(
                f'([་།༽༼\s༿>]+)({str(sent)})([་༽༈།༔༾\s<]+)', '\\1[\\2]\\3', res_strn, 0, re.MULTILINE)

            # словарь найденных вхождений sent в исход строку
            res_dct[sent] = dct_ptcl[sent]

print("res_strn1:   ", res_strn)

# Присоединяем оторванные частицы обратно
res_strn = re.sub(f'((པ|པོ|བ|བོ|དེ|འདི)\])་(\[ར\])', r'\1\3', res_strn)
res_strn = re.sub(f'((པ|པོ|བ|བོ|དེ|འདི)\])་(\[ས\])', r'\1\3', res_strn)
for syl in ['འིས', 'འང', 'འམ', 'འི', 'འུ']:
    res_strn = re.sub(f'་(\[{syl}\])', r"\1", res_strn)


res_strn = re.sub(f'(གོ|ངོ[་]*|དོ|ནོ|བོ|མོ|རོ|ལོ|སོ|ཏོ|འོ)#',
                  '<a def="¶" class="cc">\\1</a>', res_strn)
res_strn = res_strn.replace('#', '')


print('strn:  ', strn)
print('res_strn2:  ', res_strn)
#print(*res_dct.items(), sep="\n")
print('res_dct', res_dct)

#-----------------------------------------------------------------------
# 3. Создаем строки вывода с HTML тегами ОКНА

dct_str = ""

res_strn = re.sub(
    f'(\[)([\w+?ཱཱཱིིུུྲྀཷླྀཹེཻོཽཾཱྀྀྂྃྐྑྒྒྷྔྕྖྗྙྚྛྜྜྷྞྟྠྡྡྷྣྤྥྦྦྷྨྩྪྫྫྷྭྮྯྰྱྲླྴྵྶྷྸྐྵྺྻྼ]+་)*(\[)', '[\\2', res_strn, 0)
res_strn = re.sub(
    f'(\])((་[\w+?ཱཱཱིིུུྲྀཷླྀཹེཻོཽཾཱྀྀྂྃྐྑྒྒྷྔྕྖྗྙྚྛྜྜྷྞྟྠྡྡྷྣྤྥྦྦྷྨྩྪྫྫྷྭྮྯྰྱྲླྴྵྶྷྸྐྵྺྻྼ]+)*)(\])', '\\2]', res_strn, 0)

cont_ = 1

# исходная строка
#res_strn

# старая подстрока - заменяемая часть строки
subStrOld = '['

# длина старой подстроки
lenStrOld = len(subStrOld)

# Функция find() возвращает индекс первого символа
# подстроки. Если подстроки нет, то возвращает -1.
# Цикл используется на случай, если в строке
# несколько одинаковых подстрок.
while cont_ < res_strn.find(subStrOld):
    # новая подстрока
    subStrNew = '_'+str(cont_)+'_'
    # сохранить в переменную индекс первого элемента
    # старой подстроки
    i = res_strn.find(subStrOld)
    # Перезаписать строку: взять срез от начала до индекса,
    # добавить новую подстроки и соединить со срезом от конца
    # старой подстроки.
    res_strn = res_strn[:i] + subStrNew + res_strn[i+lenStrOld:]
    cont_ += 1

#res_strn=re.sub(f'(\d+)({k})\]',
print(res_strn)

#print(res_strn)
lst = list(dict.fromkeys(re.findall(r'_\d+_(\S+?)\]', res_strn)))

#print(lst)
cnt = 1
for ind, k in enumerate(lst):  # идем по строке
    # создаем тэги для строки
    #res_strn=res_strn.replace(f'[{k}]', f'<a id="{cnt}" def="{res_dct[k]}" class="{part_speech}" href="#h{cnt}">{k}</a>')
    res_strn = re.sub(
        f'_(\d+)_({k})\]', f'<a id="\\1_{k}" def="{res_dct[k][1]}" class="{res_dct[k][0]}" href="#h_{k}">{k}</a>', res_strn, 0)
    # собираем опции для списка значений
    add = ""
    num = 1
    for itm in res_dct[k]:
        add += f'<div class="option" id="o{num}"><div class="vote_line" style="width: 57%;"></div>{itm}</div>'
        num += 1

    #создаем тэги для словарика
    dct_str += f'<a href="#" id="h_{k}">{add}</a>\n'  # завернуть в тиб тег
    cnt += 1

#print(res_strn)
#print(dct_str)

#--------------------------------------------------------------------------------
# 4.а) Запись в HTML

with open('!_JS_lotsawa9.html', 'r', encoding='utf-8') as f:
    res_html = f.read()

    #пишем тэги для строки
    res_html = re.sub(r'<section lang="bo" id="Result">\n([\s\S]*?)</section>',
                      f'<section lang="bo" id="Result">\n{res_strn}\n</section>', res_html)
    #пишем тэги для словарика
    res_html = re.sub(r'<section id="Slovar" class="Dict">\n([\s\S]*?)</section>',
                      f'<section id="Slovar" class="Dict">\n{dct_str}</section>', res_html)

with open('!_JS_lotsawa9.html', 'w', encoding='utf-8') as wf:
    wf.write(res_html)
